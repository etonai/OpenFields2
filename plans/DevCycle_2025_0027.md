# DevCycle 2025-0027: Aiming Duration Tracking System

**Created**: 2025-01-27  
**Updated**: 2025-01-27  
**Status**: Implementation Complete  
**Implementation Status**: ✅ **COMPLETED**  

## Overview

DevCycle 27 implements an aiming duration tracking system that monitors and reports the time characters spend in aiming or pointing-from-hip states before firing. This system provides tactical feedback by displaying the number of ticks spent in these targeting states when shots are fired.

Following the established project workflow, this cycle will implement targeted enhancements to the OpenFields2 tactical combat system while maintaining full backwards compatibility and system stability.

## Development Cycle Goals

- [ ] **Aiming Duration Tracking**: Implement tick-based timing for aiming and pointing-from-hip states
- [ ] **Combat Feedback Enhancement**: Add duration reporting to firing console output
- [ ] **State Transition Integration**: Seamlessly integrate with existing weapon state progression system
- [ ] **Quality Assurance**: Maintain system stability and backwards compatibility
- [ ] **Documentation**: Update relevant documentation and maintain development workflow standards

## Prerequisites

### Dependencies
- [ ] DevCycle 26 firing preference system (✅ **COMPLETED**)
- [ ] Current codebase in stable state with all tests passing
- [ ] Existing weapon state progression system functionality
- [ ] Combat firing and console output systems

### Technical Requirements
- [ ] Java 21 with JavaFX 21.0.2 environment
- [ ] Access to existing weapon systems and combat infrastructure
- [ ] GameClock tick timing system for duration calculations
- [ ] Character weapon state management system

## Estimated Complexity

**Assessment**: Low-Medium Complexity
- **Development Time**: 2-3 hours
- **Testing Effort**: 1-2 hours
- **Integration Complexity**: Low (builds on existing systems)

**Justification**: This is a targeted enhancement that adds timing tracking to existing weapon states. The implementation requires minimal new infrastructure since it leverages the established weapon state system and GameClock. The main complexity lies in ensuring accurate timing across all weapon state transitions and integrating the output with existing firing messages.

---

## System Implementations

### ✅ System 1: Aiming Duration Tracking Infrastructure

**Status**: ✅ **COMPLETED**  
**Priority**: High  
**Estimated Hours**: 1.5-2 hours

#### Task Checklist
- [x] **Task 1.1**: Add timing fields to Character class for aiming and pointing-from-hip states
- [x] **Task 1.2**: Implement timing capture when entering aiming or pointedfromhip weapon states
- [x] **Task 1.3**: Reset timing when exiting these states or changing targets
- [x] **Task 1.4**: Add duration calculation helper methods

#### Design Specifications
**Timing Fields Required:**
- `aimingStartTick` (long): Tick when aiming state began
- `pointingFromHipStartTick` (long): Tick when pointedfromhip state began
- Current tracking should distinguish between the two states based on firing preference

**State Transition Integration:**
- Capture timing when weapon state transitions to "aiming" or "pointedfromhip"
- Reset timing when transitioning away from these states
- Handle target changes (reset timing when switching targets)
- Maintain timing across weapon ready sequences that end in these states

#### Technical Implementation Notes
**Character.java modifications:**
- Add new timing fields to character state
- Implement `startAimingTiming(long currentTick)` method
- Implement `startPointingFromHipTiming(long currentTick)` method
- Implement `getAimingDuration(long currentTick)` and `getPointingFromHipDuration(long currentTick)` methods
- Add timing reset logic for target changes and state transitions

### ✅ System 2: Combat Output Integration

**Status**: ✅ **COMPLETED**  
**Priority**: High  
**Estimated Hours**: 1-1.5 hours

#### Task Checklist
- [x] **Task 2.1**: Modify firing console output to include aiming/pointing duration
- [x] **Task 2.2**: Integrate duration calculation with existing firing messages
- [x] **Task 2.3**: Handle both single shots and burst/automatic fire scenarios
- [x] **Task 2.4**: Ensure consistent output format across all weapon types

#### Design Specifications
**Console Output Format:**
- Extend existing firing messages: `"Alice fires a MP5 at Chris, shootingfromaiming (aimed 23 ticks), at tick 75"`
- Or for point-from-hip: `"Alice fires a MP5 at Chris, shootingfromhip (pointed 15 ticks), at tick 75"`
- Duration should show actual ticks spent in the specific firing state

**Integration Points:**
- Firing messages in weapon firing sequences
- Both ranged weapon firing output and console integration
- Burst fire scenarios (show duration for first shot only)
- Multiple target scenarios

#### Technical Implementation Notes
**Files to modify:**
- Combat firing output generation (wherever firing console messages are created)
- Integration with existing firing state detection logic
- Duration calculation at moment of firing (before state changes)
- Proper handling of edge cases (very short or zero duration aiming)

### System 3: Accumulated Aiming Time Bonus System

**Status**: Planning Phase  
**Priority**: High  
**Estimated Hours**: 2-3 hours

#### Task Checklist
- [ ] **Task 3.1**: Design accumulated aiming time bonus calculation system with weapon-specific base timings
- [ ] **Task 3.2**: Implement `calculateEarnedAimingBonus()` method in Character class
- [ ] **Task 3.3**: Create `AccumulatedAimingBonus` enum for earned bonus levels
- [ ] **Task 3.4**: Integrate accumulated time bonuses with CombatCalculator accuracy calculations
- [ ] **Task 3.5**: Update console output to show selected speed, duration, and earned bonus
- [ ] **Task 3.6**: Add unit tests for accumulated time bonus calculations

#### Design Specifications

**Time-Based Accuracy Bonus System:**
The system rewards maintaining aim on targets with accuracy bonuses based on accumulated duration. The earned bonus is independent of the selected aiming speed, allowing tactical flexibility.

**Base Timing Calculation (Confirmed):**
```java
// Base aiming time = weapon's specific aiming state tick duration
// Examples: 30 ticks for pistol/rifle, 25 ticks for OTHER type weapons
long baseAimingTime = getCurrentWeaponAimingStateTicks(); // From weapon state data
```

**Bonus Thresholds (Weapon-Specific):**
- **No Bonus**: < 1.0x base aiming time (+0 accuracy)
- **Normal Bonus**: ≥ 1.0x base aiming time (+0 accuracy, serves as baseline)
- **Careful Bonus**: ≥ 2.0x base aiming time (+15 accuracy)  
- **Very Careful Bonus**: ≥ 3.0x base aiming time (+15 accuracy + skill benefits)

**Example (Pistol with 30 tick base):**
- No Bonus: 0-29 ticks
- Normal: 30-59 ticks  
- Careful: 60-89 ticks
- Very Careful: 90+ ticks

**State-Specific Restrictions:**
- **Aiming State**: Can earn up to Very Careful bonus
- **Pointing-from-hip State**: Capped at Normal bonus (no positive accuracy modifier)
- Very Careful bonus requires weapon skill level 1+ (existing requirement)

**Bonus Interaction Rules (Confirmed):**
1. **Selected vs Earned**: When an earned bonus exists, completely ignore selected aiming speed and use only the earned bonus (e.g., Quick selection ignored when Careful bonus earned)
2. **Skill Requirements**: Very Careful benefits require weapon skill level 1+ regardless of how earned
3. **First Shot Only**: For burst/auto fire, only first shot gets accumulated time bonus
4. **Target Consistency**: Bonus only applies if target hasn't changed during accumulation
5. **Movement**: Movement has no effect on time accumulation (movement penalties still apply separately)

#### Technical Implementation Notes

**New AccumulatedAimingBonus Enum:**
```java
public enum AccumulatedAimingBonus {
    NONE("None", 0.0),
    NORMAL("Normal", 0.0),
    CAREFUL("Careful", 15.0),
    VERY_CAREFUL("Very Careful", 15.0);
    
    private final String displayName;
    private final double accuracyModifier;
    
    // Methods: getDisplayName(), getAccuracyModifier(), isVeryCarefu()
}
```

**Implementation Architecture (Confirmed):**
The accumulated bonus calculation will be implemented in CombatCalculator.java as part of combat calculations, calculated only when firing. This keeps the bonus logic centralized with other combat modifiers.

**Character Class Support Methods:**
```java
// Support methods in Character class for CombatCalculator to use
public long getCurrentWeaponAimingStateTicks() {
    // Get base aiming time from current weapon's state data
    WeaponState aimingState = findWeaponState("aiming");
    return aimingState != null ? aimingState.ticks : 30; // Default 30 if not found
}

public boolean isInAimingOrPointingState() {
    String currentState = getCurrentWeaponStateName();
    return "aiming".equals(currentState) || "pointedfromhip".equals(currentState);
}

public boolean isPointingFromHip() {
    return "pointedfromhip".equals(getCurrentWeaponStateName());
}
```

**CombatCalculator Integration:**
```java
// Add method to CombatCalculator to calculate earned bonus
public static AccumulatedAimingBonus calculateEarnedAimingBonus(Character character, long currentTick) {
    if (!character.isInAimingOrPointingState()) return AccumulatedAimingBonus.NONE;
    
    long accumulatedTime = character.getCurrentAimingDuration(currentTick);
    long baseTime = character.getCurrentWeaponAimingStateTicks();
    
    // Apply weapon ready speed multiplier to thresholds
    double weaponReadySpeedMultiplier = character.calculateAimingSpeedMultiplier();
    long adjustedBaseTime = Math.round(baseTime * weaponReadySpeedMultiplier);
    
    // For pointing-from-hip, cap at NORMAL
    if (character.isPointingFromHip()) {
        return accumulatedTime >= adjustedBaseTime ? AccumulatedAimingBonus.NORMAL : AccumulatedAimingBonus.NONE;
    }
    
    // For aiming state, full progression available
    if (accumulatedTime >= adjustedBaseTime * 3) return AccumulatedAimingBonus.VERY_CAREFUL;
    if (accumulatedTime >= adjustedBaseTime * 2) return AccumulatedAimingBonus.CAREFUL;
    if (accumulatedTime >= adjustedBaseTime) return AccumulatedAimingBonus.NORMAL;
    return AccumulatedAimingBonus.NONE;
}

// Modify determineHit to use accumulated bonus
public static HitResult determineHit(Unit attacker, Unit target, ..., long currentTick) {
    // Calculate earned bonus at time of firing
    AccumulatedAimingBonus earnedBonus = calculateEarnedAimingBonus(attacker.character, currentTick);
    
    // Use earned bonus if present, otherwise use selected aiming speed
    double finalAimingModifier;
    boolean useVeryCarefulBenefits = false;
    
    if (earnedBonus != AccumulatedAimingBonus.NONE) {
        // Use only earned bonus when present
        finalAimingModifier = earnedBonus.getAccuracyModifier();
        useVeryCarefulBenefits = earnedBonus.isVeryCareful() && meetsVeryCarefulSkillRequirements(attacker.character);
    } else {
        // Fall back to selected aiming speed
        AimingSpeed selectedSpeed = attacker.character.getCurrentAimingSpeed();
        finalAimingModifier = selectedSpeed.getAccuracyModifier();
        useVeryCarefulBenefits = selectedSpeed.isVeryCareful() && meetsVeryCarefulSkillRequirements(attacker.character);
    }
    
    // For burst fire shots 2+, ignore all aiming modifiers
    if (shotNumber > 1) {
        finalAimingModifier = 0; // Burst penalty applied elsewhere
    }
}

// In Character.scheduleAttackFromCurrentState, add Very Careful random time
AccumulatedAimingBonus earnedBonus = CombatCalculator.calculateEarnedAimingBonus(this, currentTick);
if (earnedBonus == AccumulatedAimingBonus.VERY_CAREFUL && "aiming".equals(currentState)) {
    // Add 2-5 seconds random time, same as selected Very Careful
    long additionalTime = 120 + (long)(Math.random() * 181); // 120-300 ticks
    fireDelay += additionalTime;
}
```

**Console Output Enhancement (Confirmed Format):**
```java
// When earned bonus exists - show earned bonus
"Alice fires a Colt Peacemaker at Bob, shootingfromaiming (aimed 95 ticks, earned Very Careful bonus), at tick 150"
"Charlie fires a Hunting Rifle at Dave, shootingfromhip (pointed 45 ticks, earned Normal bonus), at tick 200"

// When no earned bonus - show selected aiming speed
"Eve fires a Derringer at Frank, shootingfromaiming (aimed 15 ticks, using Quick aiming), at tick 50"
"Dan fires a Hunting Rifle at Eve, shootingfromaiming (aimed 25 ticks, using Normal aiming), at tick 75"
```

#### Edge Cases and Considerations (Confirmed)

**Target Change Handling:**
- All accumulated time is lost when switching targets
- No carryover or quick re-aim bonuses

**Weapon Switch Scenarios:**
- Switching weapons resets accumulated time
- Base timing recalculated for new weapon type

**Movement During Aiming:**
- Movement has no effect on time accumulation
- Movement penalties still apply independently to accuracy
- Character can move freely while accumulating aiming time

**Burst Fire Consideration (Confirmed):**
- Only first shot benefits from accumulated time bonus
- Subsequent burst shots use standard burst penalty only (-20 accuracy)
- No aiming speed modifiers apply to shots 2+ in burst (neither selected nor earned)
- Example: Quick selected + Careful earned = Shot 1: +15, Shot 2+: -20

**Defensive Aiming:**
- Accumulated time bonuses apply normally when finally firing
- No maximum cap or timeout for defensive hold states

**Character Stats Display:**
- No real-time display of accumulated time or potential bonuses
- Bonus information only shown in console output when firing

---

## Technical Architecture

### Code Organization
**Files to be Modified**:
- `src/main/java/combat/Character.java` - Add timing fields and duration tracking methods
- Firing output generation locations (to be identified during implementation)
- Weapon state transition code (integration with existing progression system)

**New Functionality**:
- Timing capture infrastructure in Character class
- Duration calculation and reporting methods
- Console output enhancement for firing messages

### Data Flow
1. **Timing Capture**: When character enters "aiming" or "pointedfromhip" state, record current tick
2. **Duration Tracking**: Maintain timing throughout state duration, reset on target changes
3. **Firing Integration**: At moment of firing, calculate duration and integrate into console output
4. **State Reset**: Clear timing when transitioning away from aiming/pointing states

### Performance Considerations
- **Minimal Overhead**: Simple long field additions with basic arithmetic operations
- **Memory Impact**: Negligible (2 additional long fields per character)
- **Computational Cost**: Minimal (basic tick arithmetic during state transitions and firing)
- **No Performance Regression**: Implementation leverages existing timing infrastructure

---

## Testing & Validation

### Unit Testing
- [ ] **Timing Accuracy**: Verify timing capture starts correctly when entering aiming/pointing states
- [ ] **Duration Calculation**: Test duration calculation methods return accurate tick counts
- [ ] **State Reset Logic**: Confirm timing resets properly on target changes and state transitions
- [ ] **Backwards Compatibility**: Verify existing functionality remains intact

### System Integration Testing
- [ ] **Weapon State Integration**: Test timing capture across all weapon state progressions
- [ ] **Firing Output Integration**: Verify console output includes correct duration information
- [ ] **Multi-target Scenarios**: Test timing resets when switching between targets
- [ ] **Cross-system Validation**: Ensure compatibility with firing preference system from DevCycle 26

### User Experience Testing
- [ ] **Console Output Clarity**: Verify firing messages are clear and informative
- [ ] **Timing Accuracy Validation**: Manual verification of reported durations match actual timing
- [ ] **Edge Case Handling**: Test very short aiming durations and immediate firing scenarios
- [ ] **Workflow Integration**: Ensure seamless integration with existing combat workflows

### Technical Validation
- [ ] **Code Quality**: Maintain project coding standards
- [ ] **Performance**: No regression in system performance
- [ ] **Memory Usage**: Efficient resource utilization
- [ ] **Timing Precision**: Verify tick-based timing accuracy across different scenarios

---

## Implementation Timeline

### Phase 1: Foundation (Estimated: 0.5 hours)
- [ ] **Code Analysis**: Locate firing output generation and weapon state transition points
- [ ] **Architecture Verification**: Confirm integration approach with existing systems
- [ ] **Implementation Planning**: Finalize specific code modification locations

### Phase 2: Core Systems (Estimated: 2 hours)
- [ ] **Timing Infrastructure**: Add timing fields and methods to Character class
- [ ] **State Integration**: Implement timing capture in weapon state transitions
- [ ] **Duration Calculation**: Create helper methods for duration reporting
- [ ] **Unit Testing**: Validate timing capture and calculation accuracy

### Phase 3: Integration (Estimated: 1 hour)
- [ ] **Console Output Integration**: Modify firing messages to include duration
- [ ] **Cross-system Testing**: Validate with firing preference system and weapon states
- [ ] **Edge Case Handling**: Test and resolve timing edge cases

### Phase 4: Polish and Documentation (Estimated: 0.5 hours)
- [ ] **Output Format Refinement**: Ensure clear and consistent console messages
- [ ] **Documentation Updates**: Update CLAUDE.md with new timing feature
- [ ] **Final Testing**: Comprehensive validation across multiple scenarios

---

## Quality Assurance

### Code Quality
- [ ] **Coding Standards**: Follow established project conventions
- [ ] **Error Handling**: Implement robust error handling
- [ ] **Code Review**: Internal review of all implementations
- [ ] **Documentation**: Inline documentation for complex logic

### Documentation Requirements
- [ ] **CLAUDE.md Updates**: Document new features and mechanics
- [ ] **Technical Documentation**: Update relevant technical specs
- [ ] **User Guide Updates**: Update any user-facing documentation

### Deployment Checklist
- [ ] **Build Verification**: Confirm clean compilation
- [ ] **Test Suite**: All tests passing
- [ ] **Integration Testing**: Verify with existing systems
- [ ] **Performance Validation**: No performance regressions

---

## Risk Assessment

### Technical Risks
**[Risk Category 1]**: [To be identified]
- **Probability**: [To be assessed]
- **Impact**: [To be evaluated]
- **Mitigation**: [Strategy to be developed]

### Schedule Risks
**[Schedule Risk 1]**: [To be identified]
- **Probability**: [To be assessed]
- **Impact**: [To be evaluated]
- **Mitigation**: [Strategy to be developed]

### Quality Risks
**[Quality Risk 1]**: [To be identified]
- **Probability**: [To be assessed]
- **Impact**: [To be evaluated]
- **Mitigation**: [Strategy to be developed]

---

## Success Criteria

### Functional Requirements
- [ ] **Timing Tracking**: Characters accurately track time spent in aiming and pointing-from-hip states
- [ ] **Duration Reporting**: Firing console output displays correct tick count for aiming/pointing duration
- [ ] **State Integration**: Timing system seamlessly integrates with existing weapon state progression
- [ ] **Backwards Compatibility**: All existing functionality preserved

### Quality Requirements
- [ ] **Code Quality**: Meets project standards
- [ ] **Performance**: No performance degradation
- [ ] **Reliability**: Stable operation under normal conditions
- [ ] **Maintainability**: Clean, well-documented implementation
- [ ] **Timing Accuracy**: Precise tick-based duration measurements

### User Experience Requirements
- [ ] **Clear Feedback**: Console output provides valuable tactical information about aiming duration
- [ ] **Consistent Format**: Uniform message format across all weapon types and firing scenarios
- [ ] **Integration**: Seamless integration with existing combat workflows and firing preference system

---


## Post-Implementation Review

### Implementation Summary
DevCycle 27 successfully implemented a comprehensive aiming duration tracking system that monitors and reports the time characters spend in aiming or pointing-from-hip states before firing. The system seamlessly integrates with the existing weapon state progression and firing preference systems from DevCycle 26.

### Key Achievements
- **Timing Infrastructure**: Added `aimingStartTick` and `pointingFromHipStartTick` fields to Character class with supporting methods
- **State Integration**: Implemented timing capture at all key weapon state transition points including state progression, firing preference changes, and recovery transitions
- **Console Output Enhancement**: Enhanced firing messages to display duration: `"Alice fires a MP5 at Chris, shootingfromaiming (aimed 23 ticks), at tick 75"`
- **Target Change Handling**: Added automatic timing reset when characters change targets or exit aiming states
- **Backwards Compatibility**: Maintained full compatibility with existing weapon systems and firing preferences

### Files Modified
- `src/main/java/combat/Character.java` - Added timing fields, methods, and state transition integration
- `src/main/java/KeyboardInputHandler.java` - Updated toggleFiringPreference call to pass currentTick
- `src/test/java/AimingDurationTest.java` - Added comprehensive unit tests for timing functionality

### Lessons Learned
- **Strategic Integration Points**: State transitions occur in multiple locations (scheduleStateTransition, scheduleReadyStateTransition, handleFiringPreferenceStateAdjustment, recovery transitions) requiring careful integration
- **Timing Parameter Threading**: Adding currentTick parameter to toggleFiringPreference required updating the call chain from KeyboardInputHandler
- **Console Output Timing**: Duration calculation must occur before state reset to capture accurate timing at moment of firing
- **Reset Strategy**: Timing reset is crucial at target changes and after firing to ensure fresh timing for new engagements

---

## Development Cycle Workflow Reference

### Git Workflow
```bash
# Create development branch
git checkout -b DC_27

# Regular commits during development
git add .
git commit -m "DC-27: [specific change description]"

# Final merge to main (with user approval)
git checkout main
git merge DC_27
git branch -d DC_27
```

### Testing Commands
```bash
# Compile and run tests
mvn compile
mvn test

# Run the application
mvn javafx:run
```

### Development Notes
- Follow established project conventions and patterns
- Maintain backwards compatibility with existing systems
- Use iterative development approach with regular testing
- Document all major design decisions and implementation choices

---

## System 3 Implementation Ready

All planning questions have been answered. The Accumulated Aiming Time Bonus System is now fully specified and ready for implementation with these confirmed details:

### Key Implementation Decisions:
- **Architecture**: Bonus calculation in CombatCalculator, computed only when firing
- **Burst Fire**: First shot uses earned bonus, shots 2+ get standard burst penalty only (-20)
- **Weapon Ready Speed**: Applies same multiplier to time thresholds (faster characters earn bonuses quicker)
- **Very Careful Timing**: Earned Very Careful adds same 2-5 second random delay as selected
- **Console Output**: Shows earned bonus when present, otherwise shows selected aiming speed

The system is designed to reward patient aiming while maintaining tactical flexibility and game balance.
