# Melee Combat System - DevCycle 2025_0009
*Created: June 16, 2025 08:00 PM PST | Last Updated: June 16, 2025 09:19 PM PST | Implementation Status: **PLANNING***

## üöÄ **IMPLEMENTATION PROGRESS** 
**Overall Progress: 0/6 Phases Complete (0%)**

### üìã **PLANNED PHASES:**
- **Phase 1:** Melee Weapon Data Foundation - weapon types, stats, and properties ‚è≥
- **Phase 2:** Dual Weapon System - ranged/melee weapon management and switching ‚è≥
- **Phase 3:** Melee Combat Mechanics - attack resolution, damage, and timing ‚è≥
- **Phase 4:** Defense System - defensive mechanics and counter-attacks ‚è≥
- **Phase 5:** Skill System Integration - melee weapon skills and character progression ‚è≥
- **Phase 6:** Combat Flow Integration - range detection and tactical positioning ‚è≥

## Overview
This development cycle focuses on implementing comprehensive melee combat mechanics for OpenFields2. The primary objective is to create a dual weapon system where characters can seamlessly transition between ranged and melee combat based on tactical situations and distance.

**Development Cycle Goals:**
- Implement dual weapon system (ranged + melee weapons per character)
- Create melee combat mechanics with attack, defense, and counter-attack systems
- Integrate melee weapons with existing character stats and skill systems
- Enable automatic weapon switching based on combat range
- Provide foundation for historical period-appropriate combat scenarios

**Prerequisites:** 
- Existing ranged combat system from previous cycles
- Character statistics and skill system from DevCycle 7
- Character management foundation from DevCycle 8

**Estimated Complexity:** Medium-High - Complex combat mechanics with extensive integration requirements

## System Implementations

### 1. Melee Weapon Data Foundation ‚è≥ **PLANNED** (Phase 1)
- [ ] **Weapon Class Architecture Refactoring**
  - [ ] Create WeaponInterface for common weapon functionality
  - [ ] Refactor existing Weapon class to RangedWeapon class
  - [ ] Update all existing references to use RangedWeapon
  - [ ] Ensure backward compatibility with current ranged weapon functionality

- [ ] **Melee Weapon Types Definition**
  - [ ] Create MeleeWeaponType enum (UNARMED, TWO_WEAPON, LONG, MEDIUM, SHORT)
  - [ ] Establish weapon reach and size classifications
  - [ ] Indicate whether weapon is one-handed or two-handed
  - [ ] Indicate whether weapon is separate or melee version of ranged weapon
  - [ ] Sample weapons with type mapping:
    - Knife = SHORT
    - Tomahawk = MEDIUM  
    - Rifle (bayonet) = LONG
    - Pistol (pistol-whipping) = SHORT (no skill bonuses)
    - TWO_WEAPON = dual-wielding weapons

- [ ] **Melee Weapon Statistics System**
  - [ ] Define weapon reach: Unarmed (1.5 ft), Knife (2 ft), Tomahawk (2.5 ft), Rifle (3 ft)
  - [ ] Create defend score system for defensive capabilities
  - [ ] Implement automatic defend attempts when targeted (base 50% chance)
  - [ ] Apply Dexterity and weapon skill modifiers (+5 per skill level) to defend rolls
  - [ ] Set defend cooldown to 1 second between attempts (allows multiple defends per attack)
  - [ ] Set attack timing: 2 seconds attack + 2 seconds cooldown = 4 second total cycle
  - [ ] Calculate total reach as (1.5 feet unit radius + weapon range)
  - [ ] Set typical weapon readying time to 1.5 seconds
  - [ ] No readying time for same weapon ranged/melee mode if ranged weapon ready

- [ ] **Weapon Data Structure Implementation**
  - [ ] Create MeleeWeapon class implementing WeaponInterface
  - [ ] Add melee-specific fields: defendScore, attackSpeed, weaponRange, meleeType
  - [ ] Add handedness (one/two-handed) and weapon source (separate/ranged) flags
  - [ ] Create melee weapon factory methods
  - [ ] Remove weapon combination validation (not needed)

**Technical Requirements:**
```java
// New interface hierarchy
public interface WeaponInterface {
    String getId();
    String getName();
    int getDamage();
    // Common weapon methods
}

public class RangedWeapon implements WeaponInterface {
    // Existing ranged weapon properties (moved from old Weapon class)
    private String id;
    private String name;
    private int damage;
    private int range;
    private double velocity;
    private String ammunitionType;
    // etc.
}

public class MeleeWeapon implements WeaponInterface {
    private String id;
    private String name;
    private int damage;
    private MeleeWeaponType meleeType;  // UNARMED, TWO_WEAPON, LONG, MEDIUM, SHORT
    private int defendScore;            // 1-100 defensive capability
    private int attackSpeed;            // ticks to perform attack
    private int attackCooldown;         // ticks before next attack
    private double weaponRange;         // weapon range in feet
    private int readyingTime;           // ticks to ready weapon
    private boolean isOneHanded;        // true for one-handed weapons
    private boolean isMeleeVersionOfRanged;  // true if melee version of ranged weapon
}
```

### 2. Dual Weapon System ‚è≥ **PLANNED** (Phase 2)
- [ ] **Character Weapon Management**
  - [ ] Extend Character class with melee weapon field
  - [ ] Implement two-weapon slot system (primary ranged, primary melee)
  - [ ] Create weapon switching state machine
  - [ ] Add weapon readiness timing for transitions

- [ ] **Weapon Configuration System**
  - [ ] Design weapon loadout selection interface
  - [ ] Remove bayonet attachment/detachment mechanics (rifles include bayonets)
  - [ ] Remove weapon compatibility validation (not needed)

- [ ] **Weapon State Management**
  - [ ] Extend existing WeaponState enum with melee states
  - [ ] Add states: melee_ready, melee_attacking, switching_to_melee, switching_to_ranged
  - [ ] Note: defending is a free action without a weapon state
  - [ ] Implement state transition logic and timing
  - [ ] Use existing weapon state animations (no new switching animations)

**Design Specifications:**
- **Default Weapon Combinations**: All characters start with unarmed combat capability (no skill)
- **Historical Accuracy**: Period-appropriate weapon combinations (Civil War era focus)
- **Weapon Switching**: 1-3 second transition time based on weapon types and character reflexes
- **Bayonet System**: Rifles include bayonets as integrated melee capability

### 3. Melee Combat Mechanics ‚è≥ **PLANNED** (Phase 3)
- [ ] **Melee Attack Resolution**
  - [ ] Create melee attack targeting system
  - [ ] Implement hit calculation using Dexterity and weapon skills
  - [ ] Design damage calculation with weapon damage + Strength modifier
  - [ ] Add critical hit mechanics for melee combat

- [ ] **Melee Range Detection**
  - [ ] Define melee engagement ranges based on weapon-specific reach
  - [ ] Implement automatic range detection for weapon switching suggestions
  - [ ] Create melee opportunity detection (enemy in range, weapon ready)
  - [ ] Add tactical positioning feedback for players

- [ ] **Attack Timing and Cooldowns**
  - [ ] Implement attack speed variations per weapon type
  - [ ] Create attack cooldown system preventing attack spam
  - [ ] Add weapon recovery time after attacks
  - [ ] Remove combo attack potential (save for later cycles)

**Combat Mechanics:**
- **Hit Calculation**: (Dexterity Modifier + Weapon Skill + Weapon Accuracy) vs (Target Defense + Defend Attempt)
- **Damage Calculation**: (Weapon Damage + Strength Modifier) with critical hit multipliers
- **Attack Timing**: 4 second total cycle (2 sec attack + 2 sec cooldown)
- **Defend Success**: Base 50% + Dexterity Modifier + (Weapon Skill Level √ó 5)
- **Range Requirements**: Melee attacks only possible within weapon reach
- **Counter-Attack**: Available even if melee weapon not in ready state

### 4. Defense System ‚è≥ **PLANNED** (Phase 4)
- [ ] **Defensive Mechanics Implementation**
  - [ ] Create automatic defend attempt system when targeted
  - [ ] Implement defend success calculation using Reflexes and weapon defend score
  - [ ] Design defend cooldown to prevent continuous defending
  - [ ] Remove defensive stance options (not implemented this cycle)

- [ ] **Counter-Attack System**
  - [ ] Implement counter-attack opportunities after successful defenses
  - [ ] Create faster counter-attack timing than normal attacks
  - [ ] Design counter-attack damage bonuses
  - [ ] Add skill-based counter-attack improvement

- [ ] **Unified Defense System**
  - [ ] Combine blocking, dodging, and parrying under single "defending" action
  - [ ] Design defensive action priority system
  - [ ] Add defensive skill progression

**Defensive System Features:**
- **Automatic Defense**: Characters automatically attempt to defend when attacked
- **Defend Success**: Base 50% + Dexterity Modifier + (Weapon Skill Level √ó 5)
- **Counter-Attack Window**: 0.5-1 second window after successful defense for enhanced attack
- **Defense Cooldown**: 1 second between defensive actions (allows multiple defends per enemy attack)
- **Counter-Attack Flexibility**: Can counter-attack even if melee weapon not in ready state

### 5. Skill System Integration ‚è≥ **PLANNED** (Phase 5)
- [ ] **Melee Weapon Skills**
  - [ ] Create melee weapon skills for knife, tomahawk, rifle (melee)
  - [ ] Track meleeAttacksAttempted, meleeAttacksSuccessful, meleeWoundsInflicted by severity
  - [ ] Apply +5 accuracy per skill level (same as ranged weapons)
  - [ ] Remove advanced techniques (save for later cycles)

- [ ] **Character Stat Integration**
  - [ ] Link Dexterity to melee attack accuracy
  - [ ] Connect Strength to melee damage output
  - [ ] Tie Reflexes to defend success and counter-attacks
  - [ ] Use existing Coolness for combat stress effects

- [ ] **Skill Tracking System**
  - [ ] Track melee attacks attempted and successful
  - [ ] Track melee wounds inflicted
  - [ ] Remove skill experience and advancement (not this cycle)
  - [ ] Remove skill specialization paths (not this cycle)

**Skill Integration:**
- **Base Skills**: Weapon skills range from 0-9 (same as ranged weapons)
- **Weapon Skills**: Knife, Tomahawk, Rifle (melee) skills available
- **Skill Effects**: Apply melee weapon bonuses same way as ranged weapon bonuses
- **Advanced Techniques**: Not implemented this cycle

### 6. Combat Flow Integration ‚è≥ **PLANNED** (Phase 6)
- [ ] **Range-Based Combat Transitions**
  - [ ] Implement automatic weapon mode switching when switching attack types
  - [ ] Add/find key command to toggle between Ranged/Melee attack type
  - [ ] Remove formation impact (not this cycle)
  - [ ] Add simple melee combat visual and audio feedback (weapon appearance + WAV file)

- [ ] **Tactical Positioning System**
  - [ ] Use weapon-specific reach for engagement zones
  - [ ] Remove formation disruption (not this cycle)
  - [ ] Remove group melee mechanics (not this cycle)
  - [ ] Remove positioning advantages (not this cycle)

- [ ] **Combat Flow Enhancement**
  - [ ] Integrate melee combat with existing turn-based scheduling
  - [ ] Create smooth transitions between ranged and melee phases
  - [ ] Design mixed combat scenarios (some ranged, some melee)
  - [ ] Add combat state visualization for players

**Integration Features:**
- **Automatic Mode Switching**: Characters automatically switch weapon mode when changing attack types
- **Attack Type Toggle**: Key command toggles between ranged/melee attack modes
- **Mixed Combat**: Battles can have simultaneous ranged and melee engagements
- **Visual Feedback**: Simple weapon appearance changes and audio feedback for melee combat

## Technical Implementation Plan

### Phase 1: Melee Weapon Data Foundation (Estimated: 3-4 days)
**Priority:** High - Foundation for all other phases

**Implementation Steps:**
1. **Weapon Class Architecture Refactoring** (Day 1-2)
   - Create WeaponInterface with common weapon functionality
   - Refactor existing Weapon class to RangedWeapon class
   - Update all existing code references to use RangedWeapon
   - Ensure all existing ranged weapon functionality remains intact

2. **Melee Weapon Types and Structure** (Day 2-3)
   - Create MeleeWeaponType enum (UNARMED, TWO_WEAPON, LONG, MEDIUM, SHORT)
   - Implement MeleeWeapon class implementing WeaponInterface
   - Define weapon properties: reach, handedness, melee/ranged source
   - Remove weapon combination compatibility rules (not needed)

3. **Weapon Statistics and Factory Methods** (Day 3)
   - Create melee weapon factory methods for sample weapons
   - Define weapon reach: Unarmed (1.5 ft), Knife (2 ft), Tomahawk (2.5 ft), Rifle (3 ft)
   - Set typical timing: 2 sec attack, 2 sec cooldown, 1.5 sec readying
   - Implement defend score system with 1 second cooldown

4. **Data Validation and Testing** (Day 3-4)
   - Create unit tests for both RangedWeapon and MeleeWeapon classes
   - Validate weapon property ranges and balance
   - Remove combination logic testing (not needed)
   - Verify existing ranged weapon functionality unchanged

### Phase 2: Dual Weapon System (Estimated: 3-4 days)
**Priority:** High - Core system requirement

**Implementation Steps:**
1. **Character Weapon Slots** (Day 1-2)
   - Extend Character class with melee weapon field (primary ranged + primary melee)
   - Implement two-weapon slot management system
   - Create weapon assignment and validation logic

2. **Weapon State Machine** (Day 2-3)
   - Extend WeaponState enum with melee states (melee_ready, melee_attacking, switching)
   - Implement state transitions and timing
   - Create weapon switching logic and cooldowns
   - Note: defending is free action without weapon state

3. **Weapon Configuration Interface** (Day 3-4)
   - Design weapon loadout selection system
   - Remove bayonet attachment/detachment mechanics
   - Use existing weapon state animations for feedback

### Phase 3: Melee Combat Mechanics (Estimated: 4-5 days)
**Priority:** High - Core combat functionality

**Implementation Steps:**
1. **Attack Resolution System** (Day 1-2)
   - Create melee attack targeting and range detection
   - Implement hit calculation using character stats and skills
   - Design damage calculation with weapon and character modifiers

2. **Attack Timing and Speed** (Day 2-3)
   - Implement weapon-specific attack speeds and cooldowns
   - Create attack animation timing and feedback
   - Design attack queuing and combo potential

3. **Range and Positioning** (Day 3-5)
   - Implement melee engagement range detection
   - Create tactical positioning feedback
   - Design formation impact and group combat mechanics

### Phase 4: Defense System (Estimated: 3-4 days)
**Priority:** Medium-High - Essential for balanced combat

**Implementation Steps:**
1. **Defensive Mechanics** (Day 1-2)
   - Create automatic defend attempt system
   - Implement defend success calculation
   - Design defensive cooldowns and limitations

2. **Counter-Attack System** (Day 2-3)
   - Implement counter-attack opportunities after successful defense
   - Create enhanced counter-attack timing and damage
   - Design counter-attack skill progression

3. **Unified Defense System** (Day 3-4)
   - Integrate all defensive actions under "defending" mechanic
   - Implement defend timing and cooldown systems
   - Design defensive positioning options

### Phase 5: Skill System Integration (Estimated: 2-3 days)
**Priority:** Medium - Enhances character progression

**Implementation Steps:**
1. **Melee Skills Creation** (Day 1)
   - Create melee weapon skill types
   - Implement skill effect calculations
   - Design skill progression rates and thresholds

2. **Character Stat Integration** (Day 1-2)
   - Link existing character stats to melee combat
   - Implement stat modifier calculations
   - Create balanced stat impact on combat effectiveness

3. **Skill Advancement** (Day 2-3)
   - Implement experience gain from melee combat
   - Create skill level advancement system
   - Design advanced technique unlocks

### Phase 6: Combat Flow Integration (Estimated: 3-4 days)
**Priority:** Medium - Polish and user experience

**Implementation Steps:**
1. **Range-Based Transitions** (Day 1-2)
   - Implement automatic weapon switching suggestions
   - Create tactical decision points for players
   - Design formation impact mechanics

2. **Visual and Audio Feedback** (Day 2-3)
   - Create melee combat visual indicators
   - Implement audio feedback for different weapon types
   - Design combat state visualization

3. **Combat Flow Polish** (Day 3-4)
   - Integrate melee with existing combat scheduling
   - Create smooth ranged-to-melee transitions
   - Test and balance mixed combat scenarios

## Testing Strategy

### Unit Testing Requirements
- [ ] **Melee Weapon Data Tests**
  - [ ] Weapon property validation (damage, defend score, speed ranges)
  - [ ] Weapon type classification accuracy
  - [ ] Weapon reach and timing verification

- [ ] **Combat Mechanics Tests**
  - [ ] Hit calculation accuracy with various stat combinations
  - [ ] Damage calculation validation including critical hits
  - [ ] Attack speed and cooldown timing verification

- [ ] **Defense System Tests**
  - [ ] Defend success calculation accuracy
  - [ ] Counter-attack timing and damage verification
  - [ ] Defense cooldown and limitation enforcement

### Integration Testing
- [ ] **Dual Weapon System Tests**
  - [ ] Weapon switching timing and state management
  - [ ] Character weapon slot management
  - [ ] Weapon readiness and availability validation

- [ ] **Combat Flow Tests**
  - [ ] Range detection and automatic switching suggestions
  - [ ] Formation impact and positioning mechanics
  - [ ] Mixed ranged/melee combat scenarios

### User Experience Testing
- [ ] **Combat Feel and Balance**
  - [ ] Weapon type distinctiveness and tactical value
  - [ ] Combat pacing and engagement satisfaction
  - [ ] Skill progression reward feeling

- [ ] **Interface and Feedback**
  - [ ] Visual clarity of combat states and opportunities
  - [ ] Audio feedback effectiveness
  - [ ] User control and decision clarity

## Success Criteria

### Functional Requirements
- [ ] Characters can carry and switch between ranged and melee weapons
- [ ] Melee combat provides distinct tactical value from ranged combat
- [ ] Weapon types feel different and historically appropriate
- [ ] Defense mechanics create engaging combat interactions
- [ ] Skill system rewards melee combat participation and improvement

### Balance Requirements
- [ ] No single weapon type dominates all situations
- [ ] Defensive options remain viable without being overpowered
- [ ] Character stats meaningfully impact melee effectiveness
- [ ] Skill progression feels rewarding but not overpowered

### Integration Requirements
- [ ] Melee combat integrates seamlessly with existing ranged combat
- [ ] Character progression system accommodates melee skills
- [ ] Formation and positioning systems work with melee engagement
- [ ] Save/load system preserves melee weapon configurations and skills

## Files to Modify

### Core Implementation Files
- **`src/main/java/combat/Character.java`** - Add melee weapon slots and management
- **`src/main/java/weapons/Weapon.java`** - Refactor to abstract base class
- **`src/main/java/weapons/RangedWeapon.java`** - Refactored from existing Weapon class
- **`src/main/java/combat/CombatResolver.java`** - Add melee combat resolution logic
- **`src/main/java/OpenFields2.java`** - Integrate melee combat with game loop

### New Implementation Files
- **`src/main/java/weapons/MeleeWeapon.java`** - Specialized melee weapon class
- **`src/main/java/weapons/MeleeWeaponType.java`** - Melee weapon categorization enum
- **`src/main/java/combat/MeleeCombatResolver.java`** - Melee-specific combat logic
- **`src/main/java/combat/DefenseSystem.java`** - Parry, block, and counter-attack mechanics

### Enhancement Files
- **`src/main/java/data/CharacterData.java`** - Add melee weapon persistence
- **`src/main/java/data/CharacterFactory.java`** - Include melee weapon assignment
- **`src/main/java/InputManager.java`** - Add melee combat controls and feedback
- **`src/main/java/GameRenderer.java`** - Add melee combat visualization

## Risk Assessment

### Technical Risks
- **Combat Complexity**: Melee combat mechanics might overwhelm existing combat system
- **Performance Impact**: Additional combat calculations could affect game performance
- **Balance Challenges**: Balancing ranged vs melee combat effectiveness

### Integration Risks
- **Existing System Disruption**: Melee additions might break existing ranged combat
- **Save Compatibility**: New weapon systems might affect save file compatibility
- **User Interface Complexity**: Additional weapon management might confuse players

### Schedule Risks
- **Scope Creep**: Melee system complexity might exceed planned development time
- **Testing Requirements**: Extensive balance testing needed for combat feel
- **Polish Time**: Combat feel requires significant iteration and refinement

## Mitigation Strategies

### Technical Mitigation
- [ ] **Modular Development**: Implement melee combat as separate, composable system
- [ ] **Performance Monitoring**: Track performance impact during development
- [ ] **Incremental Testing**: Test each phase thoroughly before moving to next

### Integration Mitigation
- [ ] **Backward Compatibility**: Maintain existing ranged combat functionality
- [ ] **Progressive Enhancement**: Add melee as optional combat enhancement
- [ ] **Interface Simplicity**: Keep weapon management intuitive and optional

### Schedule Mitigation
- [ ] **Phase Prioritization**: Focus on core functionality first, polish later
- [ ] **Scope Management**: Clearly define minimum viable implementation
- [ ] **Iterative Refinement**: Plan multiple balance and polish iterations

## Connection to Future Cycles

**DevCycle 10 Foundation**: The melee combat system built here enables:
- Enhanced wound tracking with weapon-specific wound types
- Formation tactics that account for melee/ranged positioning
- Character specialization paths (melee vs ranged specialists)
- Historical battle scenarios with period-appropriate combat

**Long-term Vision**: This melee system grows into:
- Complex tactical combat with terrain and positioning advantages
- Character classes and specializations based on combat preferences
- Historical accuracy in weapon effectiveness and combat styles
- RPG-style combat depth with advanced techniques and combinations

## Design Clarifications Needed

### **Architecture Decision: WeaponInterface vs Abstract Weapon Class**

**The Question**: Should we use `WeaponInterface` for common weapon functionality, or an abstract `Weapon` base class?

### **WeaponInterface Approach**

**Pros:**
- **Flexibility**: Classes can implement multiple interfaces, allowing for complex weapon types (e.g., a weapon that's both `WeaponInterface` and `ThrowableInterface`)
- **Loose Coupling**: Forces you to think about contracts rather than implementation details
- **Testability**: Easy to create mock implementations for testing
- **No Implementation Inheritance Issues**: Avoids problems with deep inheritance hierarchies
- **Future-Proof**: Easy to add new weapon categories without affecting existing code

**Cons:**
- **Code Duplication**: Common functionality must be implemented in each class or utility methods
- **No Shared State**: Can't provide default implementations for common fields like `id`, `name`, `damage`
- **More Boilerplate**: Each implementing class needs to write getter/setter methods
- **No Constructor Sharing**: Each class defines its own constructors

### **Abstract Weapon Base Class Approach**

**Pros:**
- **Code Reuse**: Shared fields (`id`, `name`, `damage`) and methods implemented once
- **Less Boilerplate**: Common functionality inherited automatically
- **Consistent Structure**: Enforces uniform weapon data structure
- **Constructor Sharing**: Base constructor handles common initialization
- **Default Implementations**: Can provide sensible defaults for common methods

**Cons:**
- **Single Inheritance Limitation**: Java classes can only extend one base class
- **Tight Coupling**: Changes to base class affect all subclasses
- **Less Flexible**: Harder to create weapons with multiple capabilities
- **Potential Over-Engineering**: May force artificial inheritance relationships
- **Harder Testing**: More complex to mock due to implementation inheritance

### **Recommendation**

Given the current design with `RangedWeapon` and `MeleeWeapon` having similar core properties (`id`, `name`, `damage`), the **Abstract Weapon Base Class** approach is recommended because:

1. **Simpler Implementation**: Clear, distinct weapon types that benefit from shared structure
2. **Less Code Duplication**: Common fields and basic methods only need to be written once
3. **Easier Maintenance**: Changes to core weapon properties happen in one place
4. **Use Case Fits**: No complex multi-capability weapons planned that would benefit from multiple interfaces

**Recommended Structure:**
```java
public abstract class Weapon {
    protected String id;
    protected String name; 
    protected int damage;
    // Common methods and constructors
}

public class RangedWeapon extends Weapon { /* ranged-specific fields */ }
public class MeleeWeapon extends Weapon { /* melee-specific fields */ }
```

---

*This development cycle establishes the foundation for rich, tactical combat that honors historical weapon usage while providing engaging gameplay mechanics.*