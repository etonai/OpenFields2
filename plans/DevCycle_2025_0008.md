# Character Management Foundation - DevCycle 2025_0008
*Created: June 14, 2025 06:56 PM PDT | Last Design Update: June 14, 2025 09:38 PM PDT | Implementation Status: Planning*

## Overview
This development cycle focuses on establishing a robust character management foundation for OpenFields2. The primary objective is to create persistent character storage and deployment systems that will enable large-scale scenario development in future cycles.

**Development Cycle Goals:**
- Implement character creation and deployment workflow (CTRL-C/CTRL-A)
- Create persistent character storage system using faction files containing faction data and character rosters
- Redesign faction system with proper Faction class (ID, name, allies, enemies, color)
- Add unit deletion capability (DEL key with confirmation)
- Enable character statistics tracking across battle sessions

**Prerequisites:** 
- Existing character creation system in edit mode
- Current save/load framework
- Character statistics tracking from DevCycle 7

**Estimated Complexity:** Medium - Clear interfaces but requires new file management and UI integration

## System Implementations

### 1. Character Creation and Deployment System ⭕ **PENDING**
- [ ] **CTRL-C Character Creation Interface**
  - [ ] Extend existing CTRL-C handler (currently single character with placement) for batch creation without placement
  - [ ] Prompt for character quantity for batch creation
  - [ ] Display existing character archetype selection menu from edit mode
  - [ ] Add faction selection step - user selects from available factions
  - [ ] Assign sequential character IDs within batch using registry nextCharacterId
  - [ ] Create specified number of characters using selected archetype and faction
  - [ ] Save created characters to appropriate faction file in factions/ directory
  - [ ] Update nextCharacterId in factions/registry.json after batch creation
  - [ ] Provide confirmation message for successful character creation

- [ ] **CTRL-A Character Deployment Interface**
  - [ ] Implement new CTRL-A keyboard handler with multi-step workflow
  - [ ] Prompt for number of characters to deploy
  - [ ] Prompt for faction selection from available factions
  - [ ] Request click location for first unit placement (re-prompt if outside map bounds)
  - [ ] Prompt for formation direction (line right vs line down)
  - [ ] Prompt for unit spacing in feet between characters
  - [ ] Prompt for weapon selection for all deployed characters
  - [ ] Load faction data and filter non-incapacitated characters from selected faction file
  - [ ] Validate sufficient characters available before deployment
  - [ ] Position characters in formation with specified spacing
  - [ ] Arm deployed characters with selected weapon type
  - [ ] Provide error feedback if insufficient characters available

- [ ] **DEL Key Unit Deletion**
  - [ ] Implement DEL key handler for selected units
  - [ ] Add confirmation dialog for unit deletion
  - [ ] Remove unit from current scenario only (preserve faction character files)
  - [ ] Handle edge cases for units in combat or with scheduled events
  - [ ] Provide visual feedback for successful deletion

**Design Specifications:**
- **Character Creation Flow**: CTRL-C → Quantity prompt → Existing archetype menu → Faction selection → Batch creation → Save to faction file in factions/ directory
- **Character Deployment Flow**: CTRL-A → Quantity prompt → Faction selection → Click placement → Formation direction → Spacing → Weapon selection → Deploy formation → Weapon assignment
- **Unit Deletion Flow**: Select unit → DEL key → Confirmation dialog → Remove from scenario (faction files unchanged)
- **Formation System**: Line formations (right/down) with configurable spacing in feet using 7 pixels = 1 foot conversion
- **Character Filtering**: Only deploy non-incapacitated characters from faction files
- **File Organization**: factions/ directory with faction files (0.json, 1.json, 2.json, 3.json) containing faction data and character rosters
- **User Interface**: Sequential prompts for deployment workflow, formation positioning system
- **Performance Requirements**: Handle formation placement of 20+ characters efficiently
- **Error Handling**: Validation for sufficient characters, faction availability, formation placement bounds

**Technical Implementation Notes:**
- **Key Files to Modify**: `InputManager.java`, existing archetype menu code, `Character.java`, unit management code
- **New Classes/Enums**: `CharacterSelectionDialog.java`, `CharacterPersistenceManager.java`
- **Database/Save Changes**: New factions/ directory with faction files containing faction data and character rosters
- **Backwards Compatibility**: Independent of existing save system, no compatibility concerns
- **UI Implementation**: All user input dialogs and prompts are handled through console I/O, not JavaFX dialogs

**Implementation Decisions:**
1. **Character Creation Edge Cases**: Create a new faction file if faction doesn't exist
2. **Deployment Validation**: Display error message and abort deployment if insufficient characters
3. **Weapon Assignment**: Prompt player to select weapon type for all deployed characters
4. **Formation Boundaries**: Allow placement outside canvas bounds (playable area is larger)
5. **Placement Validation**: Re-prompt for click location if player clicks outside map bounds
6. **File Corruption Handling**: Deferred to future development cycle

### 2. Faction System Redesign ⭕ **PENDING**
- [ ] **Faction Class Implementation**
  - [ ] Create new Faction class with ID, name, allies, enemies properties
  - [ ] Add color property for visual identification (lowest priority)
  - [ ] Add description property for UI tooltips
  - [ ] Add battle statistics properties (victories, defeats, participations)
  - [ ] Implement faction relationship methods (isAlly, isEnemy, isNeutral)
  - [ ] Implement battle statistics update methods

- [ ] **Faction Management System**
  - [ ] Create FactionRegistry for managing all factions
  - [ ] Implement faction file persistence in factions/ directory
  - [ ] Create default faction files with faction data and empty character rosters
  - [ ] Add faction lookup and validation methods
  - [ ] Support dynamic faction creation and modification
  - [ ] Consider implementing factions/registry.json for efficient startup faction loading

- [ ] **Character-Faction Integration**
  - [ ] Update Character class to use new Faction objects instead of strings
  - [ ] Modify character creation to assign proper Faction references
  - [ ] Update faction file naming to use faction IDs
  - [ ] Ensure character deployment respects faction relationships
  - [ ] Update automated targeting to exclude allies and neutral units

**Design Specifications:**
- **Faction Properties**: ID (integer), name (string), allies (Set<Integer>), enemies (Set<Integer>), color (Color - lowest priority), description (string), victories (int), defeats (int), participations (int)
- **Faction Relationships**: Unidirectional storage - automatic neutral status for factions not in allies or enemies lists
- **Battle Statistics**: Track faction-level victories, defeats, and participations across all scenarios
- **File Storage**: factions/ directory with {factionId}.json files containing faction data and character rosters
- **File Naming**: ID-based naming (0.json, 1.json, etc.) with faction name stored inside file
- **Startup Registry**: factions/registry.json structure `{nextCharacterId: int, factions: [{id: int, name: string}]}` for efficient loading
- **Faction IDs**: Integer-based (0=NONE, 1=Union, 2=Confederacy, 3=Southern Unionists)

**Default Faction Definitions:**
- **NONE (ID: 0)**: No faction affiliation, no allies, no enemies, gray color, 0 victories/defeats/participations
- **Union (ID: 1)**: Union Army, allies with Southern Unionists (3), enemies with Confederacy (2), blue color, 0 victories/defeats/participations
- **Confederacy (ID: 2)**: Confederate States, no allies, enemies with Union (1) and Southern Unionists (3), dark gray color, 0 victories/defeats/participations
- **Southern Unionists (ID: 3)**: Pro-Union Southerners, allies with Union (1), enemies with Confederacy (2), light blue color, 0 victories/defeats/participations

**Technical Implementation Notes:**
- **Key Files to Modify**: `Character.java`, faction-related code throughout codebase
- **New Classes/Enums**: `Faction.java`, `FactionRegistry.java`
- **Database/Save Changes**: New factions/ directory with faction files containing both faction data and character rosters
- **Backwards Compatibility**: Migration strategy for existing character faction references

**Design Decisions:**
1. **Faction Relationships**: Update automated targeting to exclude allies and neutral units from targeting
2. **Relationship Validation**: No validation needed for circular relationships
3. **File Concurrency**: Not a concern for initial implementation
4. **Initialization**: Generate factions with random values if directory doesn't exist (manual JSON editing acceptable)
5. **Faction Colors**: Lowest priority for implementation
6. **Default Weapons**: Remove default weapons concept - weapons assigned during deployment

### 3. Character Persistence System ⭕ **PENDING**
- [ ] **Faction File Management**
  - [ ] Create factions/ directory structure
  - [ ] Design JSON schema for faction files: `{faction: {...}, characters: [...]}`
  - [ ] Implement faction file operations (0.json, 1.json, 2.json, 3.json) named by faction ID
  - [ ] Create file read/write operations with error handling (generate errors for corruption)
  - [ ] Support character data updates within faction files after battles
  - [ ] Implement factions/registry.json with structure: `{nextCharacterId: int, factions: [{id: int, name: string}]}`

- [ ] **Character Data Integration**
  - [ ] Store character identity, stats, and battle history (persist all data except current position)
  - [ ] Exclude weapon data and current position from persistent storage
  - [ ] Implement global unique sequential character ID system
  - [ ] Update character statistics after battle completion
  - [ ] Maintain character progression across scenarios
  - [ ] Support faction changes during deployment

**Design Specifications:**
- **Storage Format**: JSON with human-readable structure for debugging
- **File Structure**: `{faction: {...}, characters: [...]}` - faction metadata and character roster
- **Character Data**: All character data except current position and weapons (stats, health, battle history, etc.)
- **File Organization**: factions/ directory with ID-based files (0.json, 1.json, etc.) and registry.json
- **Character IDs**: Global unique sequential integers tracked in registry file - assign sequentially in batches
- **Faction Relationships**: Stored unidirectionally (each faction lists its allies/enemies)
- **Update Timing**: Post-battle automatic updates to preserve character and faction progression
- **Error Handling**: Generate errors for corrupted files - manual user recovery

**Technical Implementation Notes:**
- **Key Files to Modify**: `Character.java`, `SaveGameController.java` (for JSON handling patterns)
- **New Classes/Enums**: `CharacterPersistenceManager.java`, `CharacterData.java`
- **Database/Save Changes**: Independent factions/ directory with faction files containing both faction data and character rosters, separate from game save system
- **Backwards Compatibility**: New system, no backwards compatibility requirements

**Implementation Approach:**
1. **JSON Schema**: Faction files contain faction metadata + character list (similar to current character system)
2. **File Corruption**: Deferred to future development cycle
3. **Performance Scale**: Deferred to future development cycle
4. **Concurrent Writes**: Deferred to future development cycle
5. **Data Migration**: Deferred to future development cycle
6. **File Locking**: Deferred to future development cycle
7. **Memory Management**: Deferred to future development cycle

### 4. Manual Victory System ⭕ **PENDING**
- [ ] **CTRL-SHIFT-V Victory Command Implementation**
  - [ ] Implement CTRL-SHIFT-V keyboard handler during battles
  - [ ] Identify all factions with characters in current scenario
  - [ ] Create faction outcome selection interface (Victory/Defeat/Participant)
  - [ ] Present sequential prompts for each faction in scenario
  - [ ] Include cancel option in victory assignment dialog
  - [ ] Validate all faction outcomes before proceeding

- [ ] **Post-Battle Faction Updates**
  - [ ] Update faction battle statistics (victories++, defeats++, participations++)
  - [ ] Update character battle statistics for ALL characters in scenario (including incapacitated)
  - [ ] Update character victory outcome counts to match faction outcome
  - [ ] Update character health status and incapacitation state
  - [ ] Preserve character progression and combat experience
  - [ ] Save updated faction files with both faction and character data

- [ ] **Battle Resolution System**
  - [ ] End scenario after victory outcomes processed
  - [ ] Provide battle summary with faction results
  - [ ] Clear scenario characters while preserving faction file data
  - [ ] Reset game state for next scenario setup

**Design Specifications:**
- **Victory Workflow**: CTRL-SHIFT-V → Identify factions → Outcome selection per faction → Update faction files → End scenario
- **Faction Outcomes**: Victory (faction.victories++), Defeat (faction.defeats++), Participant (faction.participations++)
- **Character Updates**: Battle count, victory outcome counts (matching faction outcome), health status, incapacitation state, combat statistics
- **Data Persistence**: All changes saved to faction files immediately
- **User Interface**: Clear prompts for each faction with outcome buttons/selections
- **Error Handling**: Validation of faction outcomes and file save operations

**Technical Implementation Notes:**
- **Key Files to Modify**: `InputManager.java`, faction management code, battle resolution system
- **New Classes/Enums**: `VictoryOutcome` enum (VICTORY, DEFEAT, PARTICIPANT), `BattleResultsDialog.java`
- **Integration Points**: Faction file updates, character statistics updates, scenario termination
- **Data Flow**: Scenario analysis → Faction identification → Outcome collection → File updates → Scenario end
- **UI Implementation**: All faction outcome selection handled through console prompts, not JavaFX dialogs

**Victory System Approach:**
1. **No Factions Present**: No action taken if no factions in scenario
2. **Character Identification**: Use character faction property for identification
3. **User Experience**: Include cancel option in victory assignment dialog
4. **File Corruption During Update**: Deferred to future development cycle
5. **Deleted Characters**: Skip updates for characters deleted with DEL key
6. **Partial Updates**: Notify player of failures, continue with successful updates
7. **Battle State Validation**: No validation required before victory assignment

### 5. Create New Scenario System ⭕ **PENDING**
- [ ] **CTRL-SHIFT-N New Scenario Command Implementation**
  - [ ] Implement CTRL-SHIFT-N keyboard handler in InputManager
  - [ ] Create scenario name input dialog with validation
  - [ ] Create theme selection dialog using existing ThemeManager
  - [ ] Apply selected theme using ThemeManager.setCurrentTheme()
  - [ ] Clear all units from canvas and memory (units.clear())
  - [ ] Clear event queue of all scheduled events
  - [ ] Reset game state variables (nextUnitId, paused state, etc.)
  - [ ] Update window title from hardcoded "Unit Movement Game" to scenario name

- [ ] **Scenario Data Integration**
  - [ ] Add scenario name and theme fields to SaveData structure
  - [ ] Update SaveGameController to handle scenario metadata
  - [ ] Ensure save/load operations preserve scenario information
  - [ ] Store current scenario context for future reference
  - [ ] Include faction ID in character save data for faction file lookup
  - [ ] Restore window title from scenario name on save file load

- [ ] **Canvas and Memory Management**
  - [ ] Implement complete unit removal from canvas
  - [ ] Clear all visual elements (muzzle flashes, highlights, etc.)
  - [ ] Reset camera position and zoom to defaults
  - [ ] Clear selection state and reset selection manager

**Design Specifications:**
- **New Scenario Workflow**: CTRL-SHIFT-N → Scenario name input → Theme selection → Clear canvas → Apply theme → Update window title
- **Theme Integration**: Use existing ThemeManager system for theme selection and application
- **Data Persistence**: Scenario name and theme saved with game state for future loading
- **Memory Management**: Complete cleanup of previous scenario data before starting new scenario
- **User Interface**: Sequential dialogs for scenario setup with clear feedback
- **Error Handling**: Validation for scenario name input and theme selection

**Technical Implementation Notes:**
- **Key Files to Modify**: `InputManager.java`, `OpenFields2.java`, `SaveData.java`, `SaveGameController.java`
- **New Components**: Scenario name input dialog, theme selection dialog
- **Integration Points**: ThemeManager for theme switching, SaveData for persistence
- **Window Management**: Replace hardcoded window title with dynamic scenario name
- **UI Implementation**: All scenario setup prompts handled through console I/O, not JavaFX dialogs

**Implementation Decisions:**
1. **Theme Selection**: Present all available themes from ThemeManager in selection dialog
2. **Canvas Clearing**: Complete removal of all units and visual elements from memory
3. **Save Integration**: Scenario metadata included with save files for complete state restoration
4. **Error Handling**: Graceful handling of invalid scenario names and theme selection cancellation
5. **User Experience**: Clear feedback when scenario creation is complete

### 6. Documentation Updates ⭕ **PENDING**
- [ ] **README.md Updates**
  - [ ] Add character management system overview
  - [ ] Document faction system and relationships
  - [ ] Add character creation and deployment workflows
  - [ ] Include formation deployment examples

- [ ] **COMMANDS.md Updates**
  - [ ] Document CTRL-C character creation command
  - [ ] Document CTRL-A character deployment command with full workflow
  - [ ] Document DEL key unit deletion command
  - [ ] Document CTRL-SHIFT-V manual victory command
  - [ ] Document CTRL-SHIFT-N create new scenario command
  - [ ] Add faction system commands and controls

- [ ] **INSTRUCTIONS.md Updates**
  - [ ] Add step-by-step character creation guide
  - [ ] Add detailed character deployment instructions
  - [ ] Document formation setup and spacing
  - [ ] Add manual victory system instructions (CTRL-SHIFT-V)
  - [ ] Add create new scenario instructions (CTRL-SHIFT-N)
  - [ ] Add faction management guidelines
  - [ ] Include troubleshooting for character file issues

**Design Specifications:**
- **Documentation Scope**: Cover all new character management functionality
- **User Focus**: Clear step-by-step instructions for new users
- **Technical Details**: Include file locations and faction system architecture
- **Troubleshooting**: Common issues with character files and faction management
- **Examples**: Practical scenarios for character creation and deployment

**Technical Implementation Notes:**
- **Key Files to Update**: `README.md`, `COMMANDS.md`, `INSTRUCTIONS.md`
- **New Sections**: Character management, faction system, formation deployment
- **Integration**: Link documentation sections together for complete workflow coverage
- **Maintenance**: Ensure documentation stays current with implementation changes

## System Interaction Specifications
**Cross-system integration requirements and conflict resolution:**

- **Character Creation + Character Persistence**: Characters created via CTRL-C immediately saved to appropriate faction file
- **Character Deployment + Weapon System**: Deployed characters armed with scenario-appropriate weapons
- **Battle System + Character Persistence**: Post-battle statistics automatically update character records
- **Priority Conflicts**: Character persistence takes precedence over temporary scenario data
- **File Access Coordination**: Ensure atomic read/write operations to prevent data corruption

**System Integration Priorities:**
1. **Faction System Redesign**: Foundation for character organization and relationships (highest priority)
2. **Character Persistence System**: Depends on faction system for file organization (high priority)
3. **Character Creation and Deployment System**: User interface that uses both faction and persistence systems (high priority)
4. **Manual Victory System**: Battle resolution that updates faction and character data (high priority)
5. **Create New Scenario System**: Core scenario management functionality (high priority)
6. **Documentation Updates**: Ensure users understand new functionality (medium priority)

**Cross-System Integration Questions - ANSWERED:**
1. **Save System Interaction**: Characters saved in save system must include faction ID for loading full stats from faction files
2. **Startup Sequence**: Application loads faction IDs and names at startup - consider separate faction registry file for efficiency (factions/registry.json)
3. **Data Consistency**: Manual handling for now - automated consistency deferred to future cycle
4. **Application Crash Recovery**: Data corruption handling deferred to future cycle
5. **Version Compatibility**: Version compatibility deferred to future cycle
6. **Backup Strategy**: Manual user backup for now - automated backup deferred to future cycle

**Implementation Clarification Questions - ANSWERED:**
7. **Character Creation Flow**: Add faction selection step during character creation - user selects from available factions
8. **Directory Inconsistency**: Use factions/ directory throughout (characters/ directory is obsolete)
9. **Existing CTRL-C Handler**: CTRL-C already creates characters in edit mode - extend functionality for batch creation
10. **Theme vs Scenario Integration**: Scenarios must select a theme during creation - any scenario can use any theme
11. **Character Archetype Menu**: Character archetype selection exists in edit mode - integrate with new workflow
12. **Formation Placement Bounds**: No world borders defined - allow placement in larger logical area beyond canvas
13. **Weapon Assignment Timing**: Weapon selection is part of deployment workflow as already specified in plan
14. **Victory System Scope**: CTRL-SHIFT-V can be used at any time (not restricted to active battles)
15. **Window Title Persistence**: Scenario name in save file - loading restores scenario name to window title
16. **Clear Canvas Scope**: Clear all terrain features and game state (no terrain features exist yet)

## Technical Architecture

### Code Organization
**Files requiring modification:**
- **`InputManager.java`** - Add CTRL-C and CTRL-A keyboard handlers
- **`Character.java`** - Add serialization support for character persistence
- **`GameRenderer.java`** - Add UI dialogs for character creation/selection

**New Components Required:**
- **CharacterPersistenceManager**: Handles faction file operations
- **Faction**: Core faction class with properties and relationship methods
- **FactionRegistry**: Management system for all factions
- **CharacterSelectionDialog**: Console-based UI for character deployment selection
- **BattleResultsDialog**: Console-based UI for victory outcome selection per faction
- **VictoryOutcome**: Enum for victory/defeat/participant outcomes
- **CharacterData**: Serializable data structure for JSON storage
- **ScenarioNameDialog**: Console-based UI for scenario name input with validation
- **ThemeSelectionDialog**: Console-based UI for theme selection using ThemeManager

**UI Implementation Note**: All user interactions (dialogs, prompts, selections) are implemented using console I/O through System.out.println() and Scanner input, not JavaFX dialogs or GUI components.

### Data Flow
**Information flow between systems:**
1. **Application Start** → **Load Faction Registry** → **Load Character ID Counter** → **Initialize FactionRegistry** → **Ready for Character Operations**
2. **CTRL-C Press** → **Quantity Input** → **Archetype Selection** → **Faction Selection** → **Batch Character Creation** → **Save to Faction File**
3. **CTRL-A Press** → **Quantity Input** → **Faction Selection** → **Click Placement** → **Formation Direction** → **Spacing Input** → **Weapon Selection** → **Load Non-Incapacitated Characters** → **Formation Deployment** → **Weapon Assignment**
4. **DEL Key Press** → **Confirmation Dialog** → **Remove Unit from Scenario** (faction files unchanged)
5. **CTRL-SHIFT-V Press** → **Identify Scenario Factions** → **Outcome Selection per Faction** → **Update All Character Victory Counts** → **Update Faction Statistics** → **Save Faction Files** → **End Scenario**
6. **CTRL-SHIFT-N Press** → **Scenario Name Input** → **Theme Selection** → **Clear Canvas and Memory** → **Apply Theme** → **Update Window Title** → **Ready for New Scenario**

### Performance Considerations
- **Memory Impact**: Minimal - character data loaded on demand
- **CPU Usage**: Low - simple JSON operations
- **Rendering Impact**: UI dialogs only, no continuous rendering overhead
- **File I/O**: Efficient JSON parsing for character data

**Performance Questions Requiring Analysis:**
1. **Large Character Rosters**: How do faction files perform with 100+ characters per faction?
2. **Frequent Updates**: What's the performance impact of frequent faction file updates during active battles?
3. **Memory Scaling**: At what point do loaded faction files become a memory concern?
4. **Concurrent Operations**: How do multiple simultaneous faction file operations affect performance?
5. **File Size Growth**: How large can faction files become before causing performance issues?
6. **Load Time Impact**: How do large faction files affect application startup time?

**Technical Design Questions - ANSWERED:**
7. **JSON Schema Design**: Use `{faction: {...}, characters: [...]}` structure for faction files
8. **Character ID Management**: Global unique sequential integer IDs - track largest used character ID and load at game startup
9. **File Naming Convention**: Faction files named by ID (0.json, 1.json, etc.) with faction name stored inside file
10. **Error Recovery Strategy**: Generate error for corrupted files - manual user handling
11. **Character Data Scope**: Persist all character data except current position (health, stats, battle history, etc.)
12. **Faction Relationship Storage**: Store faction relationships unidirectionally
13. **Default Faction Assignment**: Obsolete - faction selection is mandatory during character creation
14. **Faction Registry File**: Implement factions/registry.json with structure for startup efficiency
15. **CTRL-C Edit Mode Verification**: Current CTRL-C creates single characters with automatic placement - extend for batch creation without placement
16. **Character ID Tracking**: Store largest used character ID in factions/registry.json
17. **Faction Registry Structure**: Use `{nextCharacterId: int, factions: [{id: int, name: string}]}` structure
18. **Character ID Assignment**: Assign IDs sequentially in batches and update nextCharacterId in registry after creation

**All Technical Design Questions - ANSWERED**

## Testing & Validation

### Unit Testing
- [ ] **Character Creation System**
  - [ ] Test CTRL-C handler activation and batch character creation
  - [ ] Test character creation with various quantities and archetypes
  - [ ] Test error handling for invalid creation parameters

- [ ] **Faction System**
  - [ ] Test Faction class creation and property assignment
  - [ ] Test faction relationship methods (isAlly, isEnemy, isNeutral)
  - [ ] Test FactionRegistry faction lookup and validation
  - [ ] Test faction file creation and loading
  - [ ] Test default faction creation and relationships (NONE, Union, Confederacy, Southern Unionists)

- [ ] **Manual Victory System**
  - [ ] Test CTRL-SHIFT-V handler activation during battles
  - [ ] Test faction identification in current scenario
  - [ ] Test victory outcome selection interface for each faction
  - [ ] Test faction statistics updates (victories/defeats/participations)
  - [ ] Test character victory outcome updates for ALL characters in scenario (including incapacitated)
  - [ ] Test faction file saves with updated battle data

- [ ] **Unit Deletion System**
  - [ ] Test DEL key handler for selected units
  - [ ] Test confirmation dialog functionality
  - [ ] Test deletion of units in various states (combat, moving, etc.)
  - [ ] Test that faction character files remain unchanged after unit deletion

- [ ] **Character Persistence System**
  - [ ] Test character data serialization/deserialization
  - [ ] Test faction file creation and updates in factions/ directory
  - [ ] Test character statistics updates after battles
  - [ ] Test error handling for corrupted character data

### System Integration Testing
- [ ] **Character Workflow Testing**
  - [ ] Test complete workflow: Create → Deploy → Battle → Update
  - [ ] Test character reuse across multiple scenarios
  - [ ] Test faction changes during deployment
  - [ ] Test character persistence across application restarts

- [ ] **Performance Testing**
  - [ ] Test character selection interface with 100+ characters
  - [ ] Test file I/O performance with large character databases
  - [ ] Test memory usage during character operations

### User Experience Testing
- [ ] **Interface Testing**
  - [ ] Test character creation dialog usability
  - [ ] Test character selection interface clarity
  - [ ] Test visual feedback for character operations
  - [ ] Test keyboard shortcut responsiveness

- [ ] **Workflow Testing**
  - [ ] Test intuitive character management workflow
  - [ ] Test error message clarity and helpfulness
  - [ ] Test character identification in selection interface

### Technical Validation
- [ ] **Compilation and Build**
  - [ ] `mvn compile` passes without errors
  - [ ] `mvn test` passes all existing tests
  - [ ] No new warnings or deprecations introduced

- [ ] **File System Testing**
  - [ ] Test factions/ directory and faction file creation in various environments
  - [ ] Test file permissions and access rights
  - [ ] Test graceful handling of read-only file systems

## Implementation Timeline

### Phase 1: Faction System Foundation (Estimated: 3 hours)
- [ ] Create Faction class with properties and relationship methods
- [ ] Implement FactionRegistry for faction management
- [ ] Create faction file structure and persistence in factions/ directory
- [ ] Implement default factions (NONE, Union, Confederacy, Southern Unionists) with defined relationships
- [ ] Test faction system core functionality

### Phase 2: Character Persistence Foundation (Estimated: 3 hours)
- [ ] Design faction file JSON schema (faction data + character roster)
- [ ] Create factions/ directory structure
- [ ] Implement CharacterPersistenceManager with faction file handling
- [ ] Update Character class to use new Faction objects
- [ ] Test character and faction serialization/deserialization

### Phase 3: Character Creation System (Estimated: 2 hours)
- [ ] Modify CTRL-C handler with quantity prompt
- [ ] Integrate with existing archetype selection menu
- [ ] Update character creation to use new faction system
- [ ] Test simplified character creation workflow

### Phase 4: Character Deployment System (Estimated: 5 hours)
- [ ] Implement CTRL-A handler with multi-step workflow
- [ ] Create faction selection interface
- [ ] Implement click-to-place positioning system
- [ ] Add formation direction prompts (line right vs line down)
- [ ] Implement spacing input and pixel conversion (7 pixels = 1 foot)
- [ ] Add character filtering for non-incapacitated characters
- [ ] Implement formation deployment with validation
- [ ] Add error handling for insufficient characters
- [ ] Test complete deployment workflow

### Phase 5: Unit Deletion System (Estimated: 1 hour)
- [ ] Implement DEL key handler for selected units
- [ ] Add confirmation dialog for unit deletion
- [ ] Test unit deletion in various scenarios
- [ ] Ensure faction file preservation

### Phase 6: Manual Victory System (Estimated: 3 hours)
- [ ] Implement CTRL-SHIFT-V keyboard handler
- [ ] Create faction identification system for current scenario
- [ ] Implement BattleResultsDialog for outcome selection
- [ ] Add faction statistics update logic
- [ ] Add character status update system (ALL characters in scenario, including incapacitated)
- [ ] Implement faction file save operations
- [ ] Add scenario termination after victory processing
- [ ] Test complete victory workflow

### Phase 7: Create New Scenario System (Estimated: 2 hours)
- [ ] Implement CTRL-SHIFT-N keyboard handler in InputManager
- [ ] Create ScenarioNameDialog for scenario name input with validation
- [ ] Create ThemeSelectionDialog using existing ThemeManager
- [ ] Implement canvas and memory clearing functionality
- [ ] Add scenario metadata to SaveData structure
- [ ] Update SaveGameController for scenario persistence
- [ ] Replace hardcoded window title with dynamic scenario name
- [ ] Test complete new scenario workflow

### Phase 8: Integration and Polish (Estimated: 2 hours)
- [ ] Integrate all systems together
- [ ] Add comprehensive error handling and validation
- [ ] Performance optimization and testing
- [ ] System integration testing

### Phase 9: Documentation Updates (Estimated: 1 hour)
- [ ] Update README.md with new character management features
- [ ] Update COMMANDS.md with CTRL-C, CTRL-A, DEL, CTRL-SHIFT-V, and CTRL-SHIFT-N functionality
- [ ] Update INSTRUCTIONS.md with character creation and deployment workflows
- [ ] Document faction system and formation deployment
- [ ] Document manual victory system (CTRL-SHIFT-V)
- [ ] Document create new scenario system (CTRL-SHIFT-N)
- [ ] Add troubleshooting section for character file issues

## Quality Assurance

### Code Quality
- [ ] **Code Review Checklist**
  - [ ] Follows project coding standards
  - [ ] Proper error handling for file operations
  - [ ] Code is well-commented and maintainable
  - [ ] No duplicate character management logic

- [ ] **Security Considerations**
  - [ ] Safe handling of JSON file operations
  - [ ] Input validation for character creation parameters
  - [ ] Protection against file system manipulation

### Documentation Requirements
- [ ] **Code Documentation**
  - [ ] CharacterPersistenceManager API documented
  - [ ] JSON schema documented
  - [ ] Character workflow documented

- [ ] **User Documentation**
  - [ ] README.md updated with character management overview
  - [ ] COMMANDS.md updated with CTRL-C, CTRL-A, DEL, and CTRL-SHIFT-V controls
  - [ ] INSTRUCTIONS.md updated with detailed workflow guides
  - [ ] Faction system and formation deployment documented
  - [ ] Manual victory system documented
  - [ ] Troubleshooting guide for character file issues

### Deployment Checklist
- [ ] **Pre-Deployment Validation**
  - [ ] All character management features functional
  - [ ] No data loss during character operations
  - [ ] Performance acceptable with large character counts
  - [ ] Error handling comprehensive and user-friendly

- [ ] **Git Management**
  - [ ] Appropriate branch created (`dc_8`)
  - [ ] Commits follow naming convention (`DC-8: Description`)
  - [ ] Ready for merge to main branch

## Risk Assessment

### Technical Risks
- **JSON File Corruption**: Medium impact - Mitigation: File validation and backup strategies
- **Performance with Large Character Sets**: Low impact - Mitigation: Efficient loading and caching
- **UI Dialog Integration**: Low impact - Mitigation: Use existing JavaFX dialog patterns

### Schedule Risks
- **Character Selection UI Complexity**: May require additional time - Contingency: Start with simple list-based selection
- **File I/O Edge Cases**: Complex error handling scenarios - Strategy: Comprehensive testing plan

### Quality Risks
- **Character Data Loss**: High impact - Testing: Extensive file operation validation
- **UI Responsiveness**: Could affect user experience - Validation: Performance testing with large datasets
- **Workflow Confusion**: Poor user experience - Validation: User experience testing and clear documentation

**Additional Risk Considerations:**
1. **File System Permissions**: What happens if the user doesn't have write permissions to create the factions/ directory?
2. **Disk Space**: How do you handle scenarios where disk space is insufficient for faction file operations?
3. **Data Corruption Cascade**: If one faction file becomes corrupted, could it affect other faction files or the entire system?
4. **Performance Degradation**: Could large faction files cause the game to become unresponsive during file operations?
5. **User Data Loss**: What safeguards exist to prevent accidental loss of hours of character development work?

## Success Criteria

### Functional Requirements
- [ ] New Faction class implemented with ID, name, allies, enemies, color, battle statistics properties
- [ ] FactionRegistry manages all factions with persistence in factions/ directory
- [ ] CTRL-C creates characters and saves to appropriate faction file
- [ ] CTRL-A loads existing characters from faction files into current scenario
- [ ] DEL key deletes selected units from scenario (preserves faction files)
- [ ] CTRL-SHIFT-V processes battle outcomes and updates faction and character data
- [ ] CTRL-SHIFT-N creates new scenarios with name and theme selection
- [ ] Characters use new Faction objects instead of string faction references
- [ ] Characters persist battle statistics across sessions
- [ ] Faction files contain both faction metadata and character rosters
- [ ] Character and faction data updates correctly after battles
- [ ] Manual victory system updates all participating factions and characters
- [ ] No data loss during character, faction, or battle resolution operations

### Quality Requirements
- [ ] Code compilation without errors or warnings
- [ ] All existing functionality preserved
- [ ] Character management features work as specified
- [ ] File operations are robust and reliable

### User Experience Requirements
- [ ] Character creation workflow is intuitive
- [ ] Character selection interface is clear and efficient
- [ ] Visual feedback confirms character operations
- [ ] Error messages are helpful and actionable

## Post-Implementation Review

### Implementation Summary
*[To be completed after implementation]*

**Actual Implementation Time**: [X hours] ([Start time] - [End time])

**Systems Completed**:
- **✅ Character Creation and Deployment System**: [Brief implementation summary]
- **✅ Character Persistence System**: [Brief implementation summary]

### Key Achievements
- [Robust character management foundation established]
- [Persistent character progression system implemented]
- [Intuitive character workflow created]
- [Foundation for future large-scale scenarios]

### Files Modified
*[Comprehensive list of all files changed during implementation]*
- **`InputManager.java`**: [Summary of keyboard handler additions]
- **`Character.java`**: [Summary of serialization support]
- **`GameRenderer.java`**: [Summary of UI dialog integration]
- **`CharacterPersistenceManager.java`**: [New file for character file operations]

### Lessons Learned
- **Technical Insights**: [What was learned about character management and file I/O]
- **Process Improvements**: [What could be done better in future cycles]
- **Design Decisions**: [Key decisions about character storage and workflow]

### Future Enhancements
- [Character import/export capabilities]
- [Advanced character filtering and search]
- [Character templates and presets]
- [Integration with scenario definition system]

---

## Development Cycle Workflow Reference

### Git Branch Management
```bash
# Create development branch
git checkout main
git pull origin main
git checkout -b dc_8

# Development workflow
git add [files]
git commit -m "DC-8: [Description]"

# Completion workflow
git checkout main
git merge dc_8
git tag devcycle-2025-0008-complete
git push origin main --tags
```

### Commit Message Format
- **Format**: `DC-8: [Brief description]`
- **Examples**: 
  - `DC-8: Implement character creation dialog with batch support`
  - `DC-8: Add characters.json persistence system`
  - `DC-8: Integrate CTRL-A character deployment workflow`

### Testing Commands
```bash
mvn compile          # Verify compilation
mvn test            # Run existing tests  
mvn javafx:run      # Manual testing
```

---

*This development cycle establishes the character management foundation that enables all future large-scale scenario development. The persistent character system allows for character progression across battles and provides the infrastructure for complex scenario systems in DevCycle 9 and beyond.*